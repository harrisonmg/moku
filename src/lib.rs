#![warn(missing_docs)]
#![doc = include_str!("../README.md")]
#![cfg_attr(docsrs, feature(doc_cfg))]
#![cfg_attr(not(feature = "std"), no_std)]

use core::marker::PhantomData;

/// Designates a module for state machine generation.
///
/// Moku expects the following items directly inside of the attributed module:
/// - an empty module attributed with [machine_module]
/// - exactly one implementation of [TopState]
/// - any number of implementations of [State]
///
/// ## Example
/// ```
/// #[moku::state_machine]
/// mod blinky {
///     use moku::*;
///
///     #[machine_module]
///     mod machine {}
///
///     use machine::BlinkyState;
///
///     struct Top;
///     impl TopState<BlinkyState> for Top {}
/// }
/// ```
///
/// ## Arguments
/// A single argument may be used to manually set the prefix of the public items generated inside
/// of the [machine_module]:
/// ```
/// #[moku::state_machine(Foo)]
/// mod blinky {
///     use moku::*;
///
///     #[machine_module]
///     mod machine {}
///
///     use machine::FooState;
///
///     struct Top;
///     impl TopState<FooState> for Top {}
/// }
/// ```
pub use moku_macros::state_machine;

/// Designates a module to be populated with the autogenerated code of a state machine.
///
/// The module must be empty and reside directly inside a module attributed with [state_machine].
///
/// ## Example
/// ```
/// #[moku::state_machine]
/// mod blinky {
///     use moku::*;
///
///     #[machine_module]
///     mod machine {}
///
///     use machine::BlinkyState;
///
///     struct Top;
///     impl TopState<BlinkyState> for Top {}
/// }
/// ```
pub use moku_macros::machine_module;

/// Designates implementations of [State] with an argument indicating their superstate.
///
/// The implementations must reside directly inside a module attributed with [state_machine].
///
/// The argument must be the name of an implementor of either [TopState] or [State].
///
/// ## Example
/// ```
/// #[moku::state_machine]
/// mod example {
///     use moku::*;
///
///     #[machine_module]
///     mod machine {}
///
///     use machine::ExampleState;
///
///     struct Top;
///     impl TopState<ExampleState> for Top {}
///
///     struct Foo;
///
///     #[superstate(Top)]
///     impl State<ExampleState> for Foo {}
///
///     struct Bar;
///
///     #[superstate(Foo)]
///     impl State<ExampleState> for Bar {}
/// }
/// ```
pub use moku_macros::superstate;

/// A flat list of all states in a state machine.
///
/// Autogenerated by moku in the [machine_module].
///
/// # Example
/// For some machine:
/// ```text
/// Top
/// ├─ Foo
/// │  └─ Bar
/// └─ Fizz
///    └─ Buzz
/// ```
/// The [StateEnum] would be:
/// ```
/// #[derive(Debug, Clone, Copy, PartialEq, Eq)]
/// pub enum BlinkyState {
///     Top,
///     Foo,
///     Bar,
///     Fizz,
///     Buzz,
/// }
/// ```
pub trait StateEnum: core::fmt::Debug + Clone + Copy + PartialEq + Eq {}

/// A state machine.
pub trait StateMachine<T: StateEnum, U: TopState<T>> {
    /// Update the state machine.
    ///
    /// Starting with the deepest state, calls [State::update] (or [TopState::update]).
    ///
    /// If any state returns `Some(state)` from its update method, that transition will be
    /// completed and the state machine will continue updating states starting from the nearest
    /// common ancestor of the previous state and the new state after transition.
    ///
    /// # Example
    /// For some machine:
    /// ```text
    /// Top
    /// ├─ Foo
    /// │  └─ Bar
    /// └─ Fizz
    ///    └─ Buzz
    /// ```
    /// If the [State::update] method of the `Bar` state will return `Some(ExampleState::Buzz)`,
    /// then:
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// #
    /// #     struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// #
    /// #     struct Fizz;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Fizz {}
    /// #
    /// #     struct Buzz;
    /// #     #[superstate(Fizz)]
    /// #     impl State<ExampleState> for Buzz {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// # machine.transition(ExampleState::Bar);
    /// assert!(matches!(machine.state(), ExampleState::Bar));
    /// machine.update();
    /// ```
    /// Will have the log output of:
    /// ```text
    /// Example: Updating
    /// │Updating Bar
    /// │Transitioning from Bar to Buzz
    /// ││Exiting Bar
    /// ││Exiting Foo
    /// ││Entering Fizz
    /// ││Entering Buzz
    /// │└Transition complete
    /// │Updating Top
    /// └Update complete
    /// ```
    /// `Top` being the nearest common ancestor of the starting state, `Bar`, and the new state,
    /// `Buzz`, so the update continues from `Top`.
    fn update(&mut self);

    /// Top-down update the state machine.
    ///
    /// Starting with the [TopState], calls [State::update] (or [TopState::update]).
    ///
    /// Useful for propagating changes to state fields before called [StateMachine::update], or for
    /// simply inverting the precedence of transitions (superstates may trigger transitions before
    /// their substates).
    ///
    /// If any state returns `Some(state)` from its update method, that transition will be
    /// completed and the state machine will continue updating states starting from the first
    /// active descendent of the nearest common ancestor of the previous state and the new state
    /// after transition.
    ///
    /// # Example
    /// For some machine:
    /// ```text
    /// Top
    /// ├─ Foo
    /// │  └─ Bar
    /// └─ Fizz
    ///    └─ Buzz
    /// ```
    /// If the [State::top_down_update] method of the `Foo` state will return `Some(ExampleState::Buzz)`,
    /// then:
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// #
    /// #     struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// #
    /// #     struct Fizz;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Fizz {}
    /// #
    /// #     struct Buzz;
    /// #     #[superstate(Fizz)]
    /// #     impl State<ExampleState> for Buzz {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// # machine.transition(ExampleState::Foo);
    /// assert!(matches!(machine.state(), ExampleState::Foo));
    /// machine.top_down_update();
    /// ```
    /// Will have the log output of:
    /// ```text
    /// Example: Top-down updating
    /// │Top-down updating Top
    /// │Top-down updating Foo
    /// │Transitioning from Foo to Fizz
    /// ││Exiting Foo
    /// ││Entering Fizz
    /// ││Entering Buzz
    /// │└Transition complete
    /// │Top-down updating Fizz
    /// │Top-down updating Buzz
    /// └Top-down update complete
    /// ```
    /// `Top` being the nearest common ancestor of the starting state, `Foo`, and the new state,
    /// `Fizz`, so the top-down update continues from the first acitve descendent of `Top`: `Fizz`.
    fn top_down_update(&mut self);

    /// Attempt to transition the [StateMachine] to the target state.
    ///
    /// Subject to short circuit transtions (from [State::enter] or [State::exit]) and initial
    /// transitions (from [State::init] or [TopState::init]).
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// #
    /// #     struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// machine.transition(ExampleState::Bar);
    /// assert!(matches!(machine.state(), ExampleState::Bar));
    /// ```
    fn transition(&mut self, target: T);

    /// Get the current state of the [StateMachine].
    ///
    /// Returns the deepest active state.
    /// # Example
    /// For some machine:
    /// ```text
    /// Top
    /// └─ Foo
    ///    └─ Bar
    /// ```
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// #
    /// #     struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// machine.transition(ExampleState::Bar);
    /// assert!(matches!(machine.state(), ExampleState::Bar));
    /// ```
    fn state(&self) -> T;

    /// Check if a given state matches the current state of this [StateMachine] or any active
    /// superstate.
    ///
    /// # Example
    /// For some machine:
    /// ```text
    /// Top
    /// ├─ Foo
    /// │  └─ Bar
    /// └─ Fizz
    /// ```
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// #
    /// #     struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// #
    /// #     struct Fizz;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Fizz {}
    /// # }
    /// # use moku::{StateMachine, StateMachineBuilder};
    /// # use example::ExampleState;
    /// # let mut machine = example::machine::ExampleMachineBuilder::new(example::Top).build();
    /// machine.transition(ExampleState::Bar);
    /// assert!(machine.state_matches(ExampleState::Top));
    /// assert!(machine.state_matches(ExampleState::Foo));
    /// assert!(machine.state_matches(ExampleState::Bar));
    /// assert!(!machine.state_matches(ExampleState::Fizz));
    /// ```
    fn state_matches(&self, state: T) -> bool;

    /// Get a reference to the top state.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// // ...
    ///      pub struct Top {
    ///         pub foo: u8,
    ///      }
    ///
    ///      impl TopState<ExampleState> for Top {}
    /// // ...
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top { foo: 8 }).build();
    ///
    /// dbg!(machine.top_ref().foo);
    /// ```
    fn top_ref(&self) -> &U;

    /// Get a mutable reference to the top state.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// // ...
    ///      pub struct Top {
    ///         pub foo: u8,
    ///      }
    ///
    ///      impl TopState<ExampleState> for Top {}
    /// // ...
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top { foo: 8 }).build();
    ///
    /// machine.top_mut().foo = 8;
    /// ```
    fn top_mut(&mut self) -> &mut U;

    /// Get the name of this state machine.
    ///
    /// This name is used in moku log messages.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// assert_eq!(machine.name(), "Example");
    /// ```
    fn name(&self) -> &str;

    /// Set the name of this state machine.
    ///
    /// This name is used in moku log messages.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    /// machine.set_name("Kikai".to_owned());
    /// assert_eq!(machine.name(), "Kikai");
    /// ```
    #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
    #[cfg(feature = "std")]
    fn set_name(&mut self, name: String);
}

/// Trait for getting references to active states.
///
/// Will be implemented by a [StateMachine] for every one of its states.
pub trait StateRef<T: StateEnum, U: State<T>> {
    /// Get a reference to the state, if currently active.
    ///
    /// Returns `None` if the state machine is not currently in the state.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// // ...
    ///     pub struct Foo;
    ///
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {}
    /// // ...
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    ///
    /// let foo: Option<&Foo> = machine.state_ref();
    /// ```
    fn state_ref(&self) -> Option<&U>;

    /// Get a mutable reference to the state.
    ///
    /// Returns `None` if the state machine is not currently in the state.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// // ...
    ///     pub struct Foo;
    ///
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {}
    /// // ...
    /// # }
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// # let mut machine = ExampleMachineBuilder::new(Top).build();
    ///
    /// let foo: Option<&mut Foo> = machine.state_mut();
    /// ```
    fn state_mut(&mut self) -> Option<&mut U>;
}

/// Builder for a [StateMachine].
pub trait StateMachineBuilder<T, U, V>
where
    T: StateEnum,
    U: TopState<T>,
    V: StateMachine<T, U>,
{
    /// Make a new [StateMachineBuilder] from a [TopState].
    ///
    /// # Example
    /// ```
    /// #[moku::state_machine]
    /// mod example {
    ///     use moku::*;
    ///
    ///     #[machine_module]
    ///     pub mod machine {}
    ///
    ///     pub use machine::ExampleState;
    ///
    ///     pub struct Top;
    ///
    ///     impl TopState<ExampleState> for Top {}
    /// }
    ///
    /// use moku::StateMachineBuilder;
    /// use example::{machine::ExampleMachineBuilder, Top};
    ///
    /// let builder = ExampleMachineBuilder::new(Top);
    /// let machine = builder.build();
    /// ```
    fn new(top_state: U) -> Self;

    /// Set the name of the [StateMachine].
    ///
    /// If not set, defaults to the [state_machine] module's name in `UpperCamel` case.
    ///
    /// # Example
    /// ```
    /// # #[state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// # }
    /// #
    /// # use moku::*;
    /// # use example::*;
    /// # use example::machine::*;
    /// let machine = ExampleMachineBuilder::new(Top).name("Kikai".to_owned()).build();
    /// assert_eq!(machine.name(), "Kikai");
    /// ```
    #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
    #[cfg(feature = "std")]
    fn name(self, name: String) -> Self;

    /// Build the [StateMachine].
    ///
    /// # Example
    /// ```
    /// #[moku::state_machine]
    /// mod example {
    ///     use moku::*;
    ///
    ///     #[machine_module]
    ///     pub mod machine {}
    ///
    ///     pub use machine::ExampleState;
    ///
    ///     pub struct Top;
    ///
    ///     impl TopState<ExampleState> for Top {}
    /// }
    ///
    /// use moku::StateMachineBuilder;
    /// use example::{machine::ExampleMachineBuilder, Top};
    ///
    /// let builder = ExampleMachineBuilder::new(Top);
    /// let machine = builder.build();
    /// ```
    fn build(self) -> V;
}

/// Return type of [State::enter].
///
/// Represents either a successful state entry or a short circuit transition.
pub enum StateEntry<T, U: StateEnum> {
    /// State entry was successful, here is the newly constructed state.
    State(T),

    /// State entry resulted in a transition, here is the target state.
    Transition(U),
}

/// A [StateMachine] state.
///
/// Implement this trait for each state in a [state_machine] module.
///
/// Must be attributed with exactly one [superstate].
pub trait State<T: StateEnum>: Sized {
    /// Type containing mutable references to all active superstates of this state.
    ///
    /// This type will be automatically defined and should not be defined by the user.
    type Superstates<'a>;

    /// Called when a [StateMachine] enters this state.
    ///
    /// Serves as a constructor for the state. If the state type is defined within the
    /// [state_machine] module and has no fields, this method can be autogenerated. If not defined
    /// by the user, it will be autogenerated and will return `StateEntry::State(Self)`.
    ///
    /// This method is only called when the state becomes active, and is not called upon re-entrant
    /// transitions (if this state is already active).
    ///
    /// Returning a value of `StateEntry::Transition(T)` will result in a "short circuit"
    /// transition that will be completed by the [StateMachine].
    ///
    /// The [State::Superstates] argument can be used to mutably access all active superstates.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// // ...
    ///     pub struct Foo {
    ///         bar: u8,
    ///     }
    ///
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {
    ///         fn enter(
    ///             superstates: &mut Self::Superstates<'_>,
    ///         ) -> StateEntry<Self, ExampleState> {
    ///             StateEntry::State(Self {
    ///                 bar: 8,
    ///             })
    ///         }
    ///     }
    /// // ...
    /// # }
    fn enter(_superstates: &mut Self::Superstates<'_>) -> StateEntry<Self, T>;

    /// Called when a [StateMachine] transitions directly to this state.
    ///
    /// This method can return a target state representing the initial transition to take upon
    /// entry of this state. It is called only when the state machine transitions directly to this
    /// state, meaning that it will not be called when transitioning with a target state that is a
    /// substate of this state.
    ///
    /// This method is called upon re-entrant transitions (if this state is already active).
    ///
    /// Returning a value of `None` results in the [StateMachine] remaining in this state after
    /// transition.
    ///
    /// The [State::Superstates] argument can be used to mutably access all active superstates.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     pub struct Foo;
    /// // ...
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {
    ///         fn init(
    ///             &mut self,
    ///             superstates: &mut Self::Superstates<'_>,
    ///         ) -> Option<ExampleState> {
    ///             Some(ExampleState::Bar)
    ///         }
    ///     }
    /// // ...
    /// #     pub struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    fn init(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        None
    }

    /// Called when [StateMachine::update] is called.
    ///
    /// This method may return a target state to transition to as a result of updating.
    ///
    /// The [State::Superstates] argument can be used to mutably access all active superstates.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     pub struct Foo;
    /// // ...
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {
    ///         fn update(
    ///             &mut self,
    ///             superstates: &mut Self::Superstates<'_>,
    ///         ) -> Option<ExampleState> {
    ///             Some(ExampleState::Bar)
    ///         }
    ///     }
    /// // ...
    /// #     pub struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    fn update(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        None
    }

    /// Called when [StateMachine::top_down_update] is called.
    ///
    /// This method may return a target state to transition to as a result of updating.
    ///
    /// The [State::Superstates] argument can be used to mutably access all active superstates.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     pub struct Foo;
    /// // ...
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {
    ///         fn top_down_update(
    ///             &mut self,
    ///             superstates: &mut Self::Superstates<'_>,
    ///         ) -> Option<ExampleState> {
    ///             Some(ExampleState::Bar)
    ///         }
    ///     }
    /// // ...
    /// #     pub struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    fn top_down_update(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        None
    }

    /// Called when a [StateMachine] exits this state.
    ///
    /// The state is consumed by this call.
    ///
    /// This method may return a target state to "short circuit" transition to as a result of
    /// exiting this state.
    ///
    /// The [State::Superstates] argument can be used to mutably access all active superstates.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// #     pub struct Top;
    /// #
    /// #     impl TopState<ExampleState> for Top {}
    /// #
    /// #     pub struct Foo;
    /// // ...
    ///     #[superstate(Top)]
    ///     impl State<ExampleState> for Foo {
    ///         fn exit(
    ///             self,
    ///             superstates: &mut Self::Superstates<'_>,
    ///         ) -> Option<ExampleState> {
    ///             Some(ExampleState::Bar)
    ///         }
    ///     }
    /// // ...
    /// #     pub struct Bar;
    /// #     #[superstate(Foo)]
    /// #     impl State<ExampleState> for Bar {}
    /// # }
    fn exit(self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        None
    }
}

/// The topmost state of a [StateMachine].
///
/// Implement this trait for exactly one state in a [state_machine] module.
pub trait TopState<T: StateEnum>: Sized {
    /// Called when a [StateMachine] initializes (upon calling [StateMachineBuilder::build]) and
    /// upon transitions directly to this state.
    ///
    /// This method can return a target state representing the initial transition to take upon
    /// entry of this state. It is called only when the state machine transitions directly to this
    /// state, meaning that it will not be called when transitioning with a target state that is a
    /// substate of this state.
    ///
    /// This method is called upon re-entrant transitions (if this state is already active, which
    /// is always true for the [TopState]).
    ///
    /// Returning a value of `None` results in the [StateMachine] remaining in this state after
    /// transition.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// // ...
    ///      pub struct Top;
    ///
    ///      impl TopState<ExampleState> for Top {
    ///         fn init(&mut self) -> Option<ExampleState> {
    ///             Some(ExampleState::Foo)
    ///         }
    ///      }
    /// // ...
    /// #
    /// #     pub struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// # }
    fn init(&mut self) -> Option<T> {
        None
    }

    /// Called when [StateMachine::update] is called.
    ///
    /// This method may return a target state to transition to as a result of updating.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// // ...
    ///      pub struct Top;
    ///
    ///      impl TopState<ExampleState> for Top {
    ///         fn update(&mut self) -> Option<ExampleState> {
    ///             Some(ExampleState::Foo)
    ///         }
    ///      }
    /// // ...
    /// #
    /// #     pub struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// # }
    fn update(&mut self) -> Option<T> {
        None
    }

    /// Called when [StateMachine::top_down_update] is called.
    ///
    /// This method may return a target state to transition to as a result of updating.
    ///
    /// # Example
    /// ```
    /// # #[moku::state_machine]
    /// # mod example {
    /// #     use moku::*;
    /// #
    /// #     #[machine_module]
    /// #     pub mod machine {}
    /// #
    /// #     pub use machine::ExampleState;
    /// #
    /// // ...
    ///      pub struct Top;
    ///
    ///      impl TopState<ExampleState> for Top {
    ///         fn top_down_update(&mut self) -> Option<ExampleState> {
    ///             Some(ExampleState::Foo)
    ///         }
    ///      }
    /// // ...
    /// #
    /// #     pub struct Foo;
    /// #     #[superstate(Top)]
    /// #     impl State<ExampleState> for Foo {}
    /// # }
    fn top_down_update(&mut self) -> Option<T> {
        None
    }
}

/// Type containing mutable references to the superstates of a [TopState], i.e. nothing.
///
/// Not indended for use by users.
pub struct NoSuperstates<'a>(PhantomData<&'a ()>);

impl<T: StateEnum, U: TopState<T>> State<T> for U {
    type Superstates<'a> = NoSuperstates<'a>;

    fn enter(_superstates: &mut Self::Superstates<'_>) -> StateEntry<Self, T> {
        unreachable!()
    }

    fn init(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        TopState::init(self)
    }

    fn update(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        TopState::update(self)
    }

    fn top_down_update(&mut self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        TopState::top_down_update(self)
    }

    fn exit(self, _superstates: &mut Self::Superstates<'_>) -> Option<T> {
        unreachable!()
    }
}

/// Types and traits for autogenerated state machine code.
///
/// The contents of this module are intended to be used only by the code that is generated by moku.
pub mod internal {
    use core::marker::PhantomData;

    use log::info;

    use super::*;

    /// The result of the attempted transition on a branch of the state tree.
    pub enum TransitionResult<T> {
        /// The target state has been reached and the transition is done.
        Done,

        /// The target state does not exist in the branch and the machine must move up the tree
        /// towards the root to find it.
        MoveUp,

        /// A short circuit transition occurred during the transition; this new target should
        /// replace the previous target state.
        NewTransition(T),
    }

    /// The substate of a [State].
    ///
    /// Also aggregates some functionality that would be attributed to the [State].
    pub trait SubstateEnum<T: StateEnum, U: State<T>> {
        /// The variant that represents no substate, i.e. being in exactly this state.
        fn none_variant() -> Self;

        /// The [StateEnum] variant that this [SubstateEnum] represents.
        fn this_state() -> T;

        /// Does this state match exactly a given [StateEnum] variant?
        fn is_state(state: T) -> bool;

        /// The current leaf state of this branch.
        fn current_state(&self) -> T {
            Self::this_state()
        }

        /// Is this state an ancesstor the the given state?
        #[allow(unused_variables)]
        fn is_ancestor(state: T) -> bool {
            false
        }

        /// Update this state and its active descendents.
        #[allow(unused_variables)]
        fn update(&mut self, state: &mut U, superstates: &mut U::Superstates<'_>) -> Option<T> {
            None
        }

        /// Update this state and its active descendents if in need of update after a transition.
        #[allow(unused_variables)]
        fn update_in_need(
            &mut self,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
        ) -> Option<T> {
            None
        }

        /// Top-down update this state and its active descendents.
        #[allow(unused_variables)]
        fn top_down_update(
            &mut self,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
        ) -> Option<T> {
            None
        }

        /// Top-down update this state and its active descendents if in need of update after a
        /// transition.
        #[allow(unused_variables)]
        fn top_down_update_in_need(
            &mut self,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
        ) -> Option<T> {
            None
        }

        /// Clear the top-down update flag from the nodes of this state's active descendents.
        fn clear_top_down_updated(&mut self) {}

        /// Exit this state and its active descendents.
        #[allow(unused_variables)]
        fn exit(
            &mut self,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
            in_update: bool,
        ) -> Option<T> {
            None
        }

        /// Transition this state and its active descendents.
        #[allow(unused_variables)]
        fn transition(
            &mut self,
            target: T,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
            in_update: bool,
        ) -> TransitionResult<T> {
            TransitionResult::MoveUp
        }

        /// Enter the substate that moves towards a target state.
        ///
        /// Panics if called when the target state is not a descendent of this state.
        #[allow(unused_variables)]
        fn enter_substate_towards(
            &mut self,
            target: T,
            state: &mut U,
            superstates: &mut U::Superstates<'_>,
            in_update: bool,
        ) -> Option<T> {
            unreachable!()
        }

        /// Does this state or any active descendents match a given state?
        fn state_matches(&self, state: T) -> bool {
            Self::is_state(state)
        }
    }

    /// The result of trying to enter a [Node].
    pub enum NodeEntry<T, U, V>
    where
        T: StateEnum,
        U: State<T>,
        V: SubstateEnum<T, U>,
    {
        /// Entry was successful, here is the new [Node].
        Node(Node<T, U, V>),

        /// Entry resulted in a short circuit transition.
        Transition(T),
    }

    /// A node in the state tree.
    pub struct Node<T, U, V>
    where
        T: StateEnum,
        U: State<T>,
        V: SubstateEnum<T, U>,
    {
        phantom: PhantomData<T>,

        #[allow(missing_docs)]
        pub state: U,

        #[allow(missing_docs)]
        pub substate: V,

        needs_update: bool,
        top_down_updated: bool,
    }

    impl<T, U, V> Node<T, U, V>
    where
        T: StateEnum,
        U: State<T>,
        V: SubstateEnum<T, U>,
    {
        /// Make a new [Node] from a [State].
        pub fn from_state(state: U) -> Self {
            Self {
                phantom: PhantomData,
                state,
                substate: V::none_variant(),
                needs_update: false,
                top_down_updated: false,
            }
        }

        /// Enter this node.
        pub fn enter(superstates: &mut U::Superstates<'_>, in_update: bool) -> NodeEntry<T, U, V> {
            info!(
                "{}\u{02502}Entering {:?}",
                if in_update { "\u{02502}" } else { "" },
                V::this_state()
            );
            match U::enter(superstates) {
                StateEntry::State(state) => NodeEntry::Node(Self {
                    phantom: PhantomData,
                    state,
                    substate: V::none_variant(),
                    needs_update: false,
                    top_down_updated: false,
                }),
                StateEntry::Transition(target) => {
                    info!(
                        "{}\u{02502}Short circuit transition to {target:?}",
                        if in_update { "\u{02502}" } else { "" },
                    );
                    NodeEntry::Transition(target)
                }
            }
        }

        /// Update this node and its active descendents.
        pub fn update(&mut self, superstates: &mut U::Superstates<'_>) -> Option<T> {
            self.needs_update = true;
            match self.substate.update(&mut self.state, superstates) {
                Some(target) => Some(target),
                None => {
                    info!("\u{02502}Updating {:?}", V::this_state());
                    self.needs_update = false;
                    self.state.update(superstates)
                }
            }
        }

        /// Update this node and its active descendents if in need of update after a transition.
        pub fn update_in_need(&mut self, superstates: &mut U::Superstates<'_>) -> Option<T> {
            if self.needs_update {
                match self.substate.update_in_need(&mut self.state, superstates) {
                    Some(target) => Some(target),
                    None => {
                        info!("\u{02502}Updating {:?}", V::this_state());
                        self.needs_update = false;
                        self.state.update(superstates)
                    }
                }
            } else {
                None
            }
        }

        /// Top-down update this node and its active descendents.
        pub fn top_down_update(&mut self, superstates: &mut U::Superstates<'_>) -> Option<T> {
            info!("\u{02502}Top-down updating {:?}", V::this_state());
            self.top_down_updated = true;
            match self.state.top_down_update(superstates) {
                Some(target) => Some(target),
                None => self.substate.top_down_update(&mut self.state, superstates),
            }
        }

        /// Top-down update this node and its active descendents if in need of update after a
        /// transition.
        pub fn top_down_update_in_need(
            &mut self,
            superstates: &mut U::Superstates<'_>,
        ) -> Option<T> {
            if !self.top_down_updated {
                info!("\u{02502}Top-down updating {:?}", V::this_state());
                self.top_down_updated = true;
                if let Some(target) = self.state.top_down_update(superstates) {
                    return Some(target);
                }
            }

            self.substate
                .top_down_update_in_need(&mut self.state, superstates)
        }

        /// Clear the top-down update flag from this node and its active descendents.
        pub fn clear_top_down_updated(&mut self) {
            self.top_down_updated = false;
            self.substate.clear_top_down_updated();
        }

        /// Exit this node and its active descendents.
        pub fn exit(self, superstates: &mut U::Superstates<'_>, in_update: bool) -> Option<T> {
            info!(
                "{}\u{02502}Exiting {:?}",
                if in_update { "\u{02502}" } else { "" },
                V::this_state()
            );

            self.state.exit(superstates).inspect(|target| {
                info!(
                    "{}\u{02502}Short circuit transition to {target:?}",
                    if in_update { "\u{02502}" } else { "" },
                );
            })
        }

        /// Transition this node and its active descendents.
        pub fn transition(
            &mut self,
            target: T,
            superstates: &mut U::Superstates<'_>,
            in_update: bool,
        ) -> TransitionResult<T> {
            // try to transition the current substate towards the target state
            match self
                .substate
                .transition(target, &mut self.state, superstates, in_update)
            {
                // substate is the target state
                TransitionResult::Done => TransitionResult::Done,

                // substate is not the target state or an ancestor of it
                TransitionResult::MoveUp => {
                    if let Some(new_target) =
                        self.substate.exit(&mut self.state, superstates, in_update)
                    {
                        // substate exit resulted in a short circuit transition
                        self.transition(new_target, superstates, in_update)
                    } else if V::is_ancestor(target) {
                        if let Some(new_target) = self.substate.enter_substate_towards(
                            target,
                            &mut self.state,
                            superstates,
                            in_update,
                        ) {
                            // substate transition resulted in a short circuit transition
                            TransitionResult::NewTransition(new_target)
                        } else {
                            // substate successfully moved towards target state,
                            // continue transitioning downwards
                            self.substate.transition(
                                target,
                                &mut self.state,
                                superstates,
                                in_update,
                            )
                        }
                    } else if V::is_state(target) {
                        // this state is the target
                        match self.state.init(superstates) {
                            None => TransitionResult::Done,
                            Some(new_target) => {
                                info!("\u{02502}Initial transition to {new_target:?}");
                                TransitionResult::NewTransition(new_target)
                            }
                        }
                    } else {
                        // this state is not the target state or an ancestor of it
                        TransitionResult::MoveUp
                    }
                }

                // substate transition resulted in a short circuit transition
                // bubble back up to top
                TransitionResult::NewTransition(new_target) => {
                    TransitionResult::NewTransition(new_target)
                }
            }
        }

        /// Get the current leaf state of this branch.
        pub fn current_state(&self) -> T {
            self.substate.current_state()
        }

        /// Does this node or any active descendents match a given state?
        pub fn state_matches(&self, state: T) -> bool {
            self.substate.state_matches(state)
        }
    }

    /// The root node of a state tree.
    pub struct TopNode<T, U, V>
    where
        T: StateEnum,
        U: TopState<T>,
        V: SubstateEnum<T, U>,
    {
        #[allow(missing_docs)]
        pub node: Node<T, U, V>,

        #[cfg(feature = "std")]
        name: String,

        #[cfg(not(feature = "std"))]
        name: &'static str,
    }

    impl<T, U, V> TopNode<T, U, V>
    where
        T: StateEnum,
        U: TopState<T>,
        V: SubstateEnum<T, U>,
    {
        /// Make a new [TopNode] from a [TopState] and a machine name.
        #[cfg(feature = "std")]
        pub fn new(top_state: U, name: String) -> Self {
            Self {
                node: Node::from_state(top_state),
                name,
            }
        }

        /// Make a new [TopNode] from a [TopState] and a machine name.
        #[cfg(not(feature = "std"))]
        pub fn new(top_state: U, name: &'static str) -> Self {
            Self {
                node: Node::from_state(top_state),
                name,
            }
        }

        /// Perform the initial transition of this node.
        pub fn init(&mut self) {
            if let Some(target) = TopState::init(&mut self.node.state) {
                info!("{}: Initial transition to {target:?}", self.name());
                self.transition_quiet(target, false);
                info!("\u{02514}Transition complete");
            }
        }

        /// Update this node and its active descendents.
        pub fn update(&mut self) {
            info!("{}: Updating", self.name());
            if let Some(target) = self.node.update(&mut NoSuperstates(PhantomData)) {
                self.transition(target, true);

                while self.node.needs_update {
                    if let Some(target) = self.node.update_in_need(&mut NoSuperstates(PhantomData))
                    {
                        self.transition(target, true);
                    }
                }
            }
            info!("\u{02514}Update complete");
        }

        /// Top-down update this node and its active descendents.
        pub fn top_down_update(&mut self) {
            info!("{}: Top-down updating", self.name());

            if let Some(target) = self.node.top_down_update(&mut NoSuperstates(PhantomData)) {
                self.transition(target, true);

                while let Some(target) = self
                    .node
                    .top_down_update_in_need(&mut NoSuperstates(PhantomData))
                {
                    self.transition(target, true);
                }
            }

            self.node.clear_top_down_updated();
            info!("\u{02514}Top-down update complete");
        }

        /// Transition this node and its active descendents without logging the start and end of
        /// the transition.
        pub fn transition_quiet(&mut self, target: T, in_update: bool) {
            match self
                .node
                .transition(target, &mut NoSuperstates(PhantomData), in_update)
            {
                TransitionResult::Done => (),
                TransitionResult::MoveUp => unreachable!(),
                TransitionResult::NewTransition(new_target) => {
                    self.transition_quiet(new_target, in_update)
                }
            }
        }

        /// Transition this node and its active descendents.
        pub fn transition(&mut self, target: T, in_update: bool) {
            if in_update {
                info!(
                    "\u{02502}Transitioning from {:?} to {target:?}",
                    self.state(),
                );
            } else {
                info!(
                    "{}: Transitioning from {:?} to {target:?}",
                    self.name(),
                    self.state(),
                );
            }

            self.transition_quiet(target, in_update);

            info!(
                "{}\u{02514}Transition complete",
                if in_update { "\u{02502}" } else { "" },
            );
        }

        /// Get the current leaf state of this state tree.
        pub fn state(&self) -> T {
            self.node.current_state()
        }

        /// Get the name of this machine.
        pub fn name(&self) -> &str {
            #[cfg(feature = "std")]
            return &self.name;

            #[cfg(not(feature = "std"))]
            return self.name;
        }

        /// Set the name of this machine.
        #[cfg(feature = "std")]
        pub fn set_name(&mut self, name: String) {
            self.name = name;
        }

        /// Does this node or any active descendents match a given state?
        pub fn state_matches(&self, state: T) -> bool {
            self.node.state_matches(state)
        }
    }
}
